# Linux-Job-Worker
Distributed Linux Job Worker

## Summary
Implement a prototype job worker service that provides an API to run arbitrary Linux processes.

## Requirements

### API
* Job worker should provide RPC API to start/stop/query status and get an output of a running job process. Any RPC mechanism that works for the task and is familiar to you is OK: GRPC, HTTPS/JSON API or anything else that can guarantee secure and reliable client-server communication.

* The API should provide simple but secure authentication and authorization mechanism.

### Client

* Client command should be able to connect to worker service and schedule several jobs

* Client should be able to query result of the job execution and fetch the logs

## Design Document

### Limitations And Scope

#### Data Management
Though the use of a database to store persistant data would be ideal, I will be instead storing the outputs and error outputs into logs stored on 
the file storage of the linux worker. The logs will be generated at start time with the foldername \<pid\>_\<startingTimestamp\>
The client will have to maintain a queue of commands, the client can query the server to see what is running to determine what can be killed,
or the client can store response data from server.

#### Scale
The scope of this project would only deal with a single linux worker interfacing with one client

### API Design

* The client will have an Command Api that takes in three types of request, Start, Stop, and Query.

* The client can then execute the commands via Execute Api

```
type CommandRequest {
    variableTypeRequest {
        StartRequest start 
        StopRequest stop 
        QueryRequest query 
    }
}

type CommandResponse {
    variableField response {
        StartResponse responseFromStart 
        StopResponse responseFromStop 
        QueryResponse responseFromQuery 
    }
}


func Execute(CommandRequest) returns(CommandResponse)

```

#### Start

* The Start command is called with a StartRequest that has the client's command and required arguments and optional env, dir params

* The Process be executed, three logs will be generated, the standard output and standard error will be redirected into a log file, one for stdout and another for stderr, the third log called programName.log will have the name of the program and arguments executed in the contents of the log. All logs will be located in the same folder with the foldername \<pid\>_\<startingTimestamp\>, a response with the pid is sent, outputs should be empty since it was just started

* When the process is completed or exit out due to errors the log folder will have a timestamp appended so pids can be reused

* A second response will be sent to indicate thats its finished with the outputs and error outputs

* Logs will be outputted to the output and errOutput (up to a certain size from the top) of the response and sent to the client via a response when done 

```

type StartRequest {
    //path of a program or executable
    string command
    //arguments to invoke program or executable with
    []string args 
    // environment variables for the execution
    //OPTIONAL variable
    []string env
    // current working directory of the execution
    //OPTIONAL variable, default will be the working directory of server 
    string dir 
}

type StartResponse {
    //process Id of the running process executed by the command
    //will be 0 if process failed to execute
    int pid 
    //stdout(standard output) of command/program executed
    string output
    //stderr(standard Error) of command/program executed
    string ErrorOutput 
    //if the command was finished it will be 0, otherwise if command successfully completes it will be 1
    bool finished
    //timestamp returns the starting time if just executed or finish time if finished
    string timeStamp 
}

```
#### Stop

* The User should be able to stop the request based on the pid

* When stopped the pid should be killed 

* A response will be sent to client indicating process have been stopped along with a the last n lines of the logs

```
type StopRequest {
    int pid
}

type StopResponse {
    string Output
    string errorOutput
}

```
* The client should be able to check what processes are still running

* The Client should be able fetch the logs and fetch the status of the process by pid and starting timestamp

* The client should able to view list of all logs generated by the server

* Client should be able to read the logs into memory and send it and  will only grab up to a certain amout of bytes from
the file to prevent maxing out string size or memory 


* There will be only two types of Query

    * QueryOneProcess:

        * get information on one pid

    * QueryRunningProcesses:

        * get list of running processes from server

    * QueryListOfLogs

        * get list of all logs generated by server 

#### Query 
```

type QueryPidRequest {
    int pid 
    string startingTimeStamp
}

type QueryPidResponse {
    string output 
    string errorOutput 
    bool isRunning 
}


type ProcessInfo {
    int32 pid 
    string startingTimeStamp 
    string processName 
    bool isRunning 
    string logPath 
}

type QueryRunningProcessesRequest {
    //will be empty since the server just needs to verify its a QueryRunningProcessesRequest
}
    
type QueryListOfLogsRequest {
    //will be empty since the server just needs to verify its a QueryListOfLogsRequest
}

message QueryListOfLogsResponse {
    repeated ProcessInfo processTable = 1;
}

type QueryRunningProcessesResponse {
     ProcessInfo[] processTable = 1;
}

type QueryRequest {
    variableField queryCommand {
        QueryPidRequest queryPid 
        QueryRunningProcessesRequest queryRunningProcesses 
    }
}

type QueryResponse {
variableField responseFromQuery {
        QueryPidResponse responseFromQueryPid
        QueryRunningProcessesResponse responseFromRunningProcesses
        QueryListOfLogsResponse responseFromListOfLogs 
    }
}

```


### Implementation Details 

* Using GRPC so the above methods and types with be generated via protocol buffers (will be using libprotoc 3.11.4)

####  DataStore

* we can use sync.Map in Go to implement a set of structs to store {pid,startTimeStamp,processName}


#### Server 

* data store for running pid, starting timestamp, process names
    
    * can be implemented with a concurrent map

* function to execute commands 

    * os/exec and syscall packages can take care of this

* logfile system management

    * can use log, writer and reader packages

    * must manage concurrency issues with read and write

* The server will only store running pids in memory and have the pass logs available in their respective \<Pid\>_\<startingTimeStamp\> folder

* concurrent go routines to handle cmd executions starting and finishing 

* killing of pid can be implemented can be done through sigkill via syscall

* Execute Api will be a bidirection streaming api, so the server can continously send back responses, while client can send new requests

#### Client

* client is responsible for constructing the commands to be passed to server via the Execute Api

* client is responsible of constructing a queue to generate commands to feed to the Execute Api


### Authentication

* Using standard GRPC tsl/ssl encryption and authentication via certificates

* we will be using grpc with mutual tls

* certificates will be generated using openssl and self-signed, though in a real production environment, certificates will be generated and signed 
by a valid certificate authority (CA). there is :

    * public domains:

        *  Letâ€™s Encrypt - a free automated open certificate authority got cert generation and distribution  

    * private domains:

        * vault to generate signing requests, centrify for renewels of certificates

### Contentious Issues

* Should the client remember commands they executed and remember the pids, starting timestamp, process command?

* Will logs that are too old be deleted by server, or should the logs just stay in the file system storage, should this be within the scope of the project?

### Development Timeline

(Will be Updated througout development)

* Setup local development environment 

    * working on Ubuntu 16.04 
    
    * install protoc 
        
        * current version
        ```
        $ protoc --version
        libprotoc 3.11.4

        ```
    * install golang 
        
        * current version
        ```
        $ go version
        go version go1.12.1 linux/amd64

        ```
    * install openssl (to generate certificates and keys)

        * current version
        ```
        $ openssl version
        OpenSSL 1.0.2g  1 Mar 2016
        ```

* Setup project directory

    * setup go modules (dependency management)
    
* Write Protocol Buffers for grpc and generate go package

* Implement Authentication and Encryption for grpc in go

* Implement Start 

* Implement Stop

* Implement Query 

* Write Tests

